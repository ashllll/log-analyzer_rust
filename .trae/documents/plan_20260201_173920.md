# 滚动到底部自动刷新功能实现方案

## 需求分析

### 功能要求
1. **滚动位置检测**：当用户滚动到页面底部50px范围内时触发刷新
2. **加载指示器**：刷新过程中显示加载动画
3. **防止重复请求**：同一时间只允许一个刷新请求
4. **错误处理**：刷新失败时显示错误提示
5. **浏览器兼容**：使用标准 Web API
6. **保持滚动位置**：刷新完成后保持用户的滚动上下文

### 后端支持情况
后端 `search_logs` 命令已支持 `offset` 和 `limit` 分页参数（见 `commands.rs` 第19-22行），可直接用于增量查询。

## 实现方案

### 步骤 1: 添加刷新相关状态和引用

**文件**: `SearchPage.tsx`

```typescript
// 刷新状态管理
const [isRefreshing, setIsRefreshing] = useState(false);

// 使用 ref 防止重复刷新请求和跟踪滚动位置
const isRefreshingRef = useRef(false);
const lastRefreshTimeRef = useRef(0);
const lastScrollTopRef = useRef(0);

// 刷新配置常量
const REFRESH_THRESHOLD = 50; // 底部50px阈值
const REFRESH_DEBOUNCE_MS = 1000; // 刷新间隔1秒
```

### 步骤 2: 实现滚动检测和刷新逻辑

**文件**: `SearchPage.tsx`

```typescript
/**
 * 检查是否接近滚动底部
 * @param scrollTop - 当前滚动位置
 * @param clientHeight - 视口高度
 * @param scrollHeight - 内容总高度
 * @returns 是否接近底部
 */
const isNearBottom = (
  scrollTop: number,
  clientHeight: number,
  scrollHeight: number
): boolean => {
  return scrollHeight - scrollTop - clientHeight <= REFRESH_THRESHOLD;
};

/**
 * 处理滚动事件
 * 被动事件监听器优化滚动性能（Vercel Best Practice）
 */
const handleScroll = useCallback((event: Event) => {
  const target = event.target as HTMLDivElement;
  const { scrollTop, clientHeight, scrollHeight } = target;
  
  // 保存滚动位置用于刷新后恢复
  lastScrollTopRef.current = scrollTop;
  
  // 检查是否正在刷新、是否到底部、是否在防抖期内
  if (isRefreshingRef.current) return;
  if (!isNearBottom(scrollTop, clientHeight, scrollHeight)) return;
  
  const now = Date.now();
  if (now - lastRefreshTimeRef.current < REFRESH_DEBOUNCE_MS) return;
  
  // 触发刷新
  lastRefreshTimeRef.current = now;
  isRefreshingRef.current = true;
  setIsRefreshing(true);
  
  // 执行刷新
  refreshLogs();
}, []);
```

### 步骤 3: 实现刷新函数

**文件**: `SearchPage.tsx`

```typescript
/**
 * 刷新日志数据
 * 追加获取新数据，不替换现有结果
 */
const refreshLogs = useCallback(async () => {
  if (!activeWorkspace) {
    isRefreshingRef.current = false;
    setIsRefreshing(false);
    return;
  }

  const trimmedQuery = query.trim();
  if (!trimmedQuery) {
    isRefreshingRef.current = false;
    setIsRefreshing(false);
    return;
  }

  const currentCount = logs.length;
  const refreshLimit = 100; // 每次刷新获取100条

  try {
    const filters = {
      time_start: filterOptions.timeRange.start,
      time_end: filterOptions.timeRange.end,
      levels: filterOptions.levels,
      file_pattern: filterOptions.filePattern || null
    };

    const result = await invoke<SearchLogsResult>("search_logs", {
      query: trimmedQuery,
      searchPath: activeWorkspace.path,
      filters,
      offset: currentCount,
      limit: refreshLimit,
    });

    if (result.results.length > 0) {
      // 追加新结果到现有列表
      const newLogs = result.results.map((r, i) => ({
        id: currentCount + i + 1,
        timestamp: r.timestamp,
        level: r.level,
        content: r.message,
        file: r.source_file,
        line: r.line_number,
        real_path: r.source_file,
        tags: [],
        match_details: null,
        matched_keywords: null,
      }));

      setLogs(prev => [...prev, ...newLogs]);
    }
  } catch (err) {
    console.error('Refresh failed:', err);
    addToast('error', `刷新失败: ${err}`);
  } finally {
    isRefreshingRef.current = false;
    setIsRefreshing(false);
  }
}, [query, activeWorkspace, filterOptions, logs.length, addToast]);
```

### 步骤 4: 添加滚动事件监听

**文件**: `SearchPage.tsx`

```typescript
// 滚动事件监听
useEffect(() => {
  const element = parentRef.current;
  if (!element) return;

  // 使用 passive 监听器优化滚动性能
  element.addEventListener('scroll', handleScroll, { passive: true });

  return () => {
    element.removeEventListener('scroll', handleScroll);
  };
}, [handleScroll]);
```

### 步骤 5: 添加加载指示器 UI

**文件**: `SearchPage.tsx`

在虚拟滚动列表底部添加：

```tsx
{/* 加载指示器 */}
{isRefreshing && (
  <div className="flex items-center justify-center py-4">
    <Loader2 className="animate-spin text-primary" size={20} />
    <span className="ml-2 text-sm text-text-muted">加载更多...</span>
  </div>
)}
```

### 步骤 6: 更新依赖数组

**文件**: `SearchPage.tsx`

确保 `handleScroll` 和 `refreshLogs` 的依赖正确：

```typescript
// handleScroll 依赖
}, [handleScroll]);

// refreshLogs 依赖
}, [query, activeWorkspace, filterOptions, logs.length, addToast]);
```

## 依赖关系
- 步骤 1 是所有其他步骤的基础
- 步骤 2 和 3 相互依赖
- 步骤 4 依赖于步骤 2
- 步骤 5 独立于其他步骤

## 复杂度分析
- **时间复杂度**: O(1) - 滚动检测和刷新触发是常量时间
- **空间复杂度**: O(1) - 只使用固定数量的状态和引用

## 验证方法
1. 运行前端开发服务器
2. 执行搜索产生结果
3. 滚动到页面底部
4. 观察加载指示器是否出现
5. 验证新结果是否追加
6. 测试错误场景（模拟网络失败）

## 浏览器兼容性
- 使用标准的 `scroll` 事件
- 使用 `{ passive: true }` 被动监听器（Chrome 51+, Firefox 49+, Safari 10+）
- 使用 `useCallback` 和 `useEffect` 确保 React 生命周期正确