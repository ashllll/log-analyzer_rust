# 关键词搜索结果完整展示修复方案

## 问题分析

### 用户需求
1. **添加新关键词后自动刷新搜索结果**
2. **保证所有搜索结果完全随滚动展示**

### 当前问题
1. 搜索只在使用搜索按钮时触发，关键词变化不会自动触发搜索
2. 搜索开始/完成时没有正确重置和跟随滚动
3. 缺少关键词变化的自动搜索机制

## 修复方案

### 步骤 1: 添加关键词变化自动搜索

**文件**: `SearchPage.tsx`

使用 `useEffect` 监听关键词变化，自动触发搜索：
```typescript
// 防抖搜索触发器
const [searchTrigger, setSearchTrigger] = useState(0);

// 监听查询变化，自动触发搜索（防抖500ms）
useEffect(() => {
  if (!query.trim()) {
    setLogs([]);
    return;
  }
  
  const timer = setTimeout(() => {
    setSearchTrigger(prev => prev + 1);
  }, 500);
  
  return () => clearTimeout(timer);
}, [query]);

// 搜索触发器变化时执行搜索
useEffect(() => {
  if (searchTrigger > 0 && activeWorkspace) {
    handleSearch();
  }
}, [searchTrigger, activeWorkspace]);
```

### 步骤 2: 重构 handleSearch 支持自动触发

**文件**: `SearchPage.tsx`

```typescript
const handleSearch = useCallback(async () => {
  if (!activeWorkspace) {
    addToast('error', 'Select a workspace first.');
    return;
  }

  const trimmedQuery = query.trim();
  if (!trimmedQuery) {
    setLogs([]);
    return;
  }

  // 重置状态
  setLogs([]);
  setSearchSummary(null);
  setKeywordStats([]);
  setIsSearching(true);
  setSelectedId(null);

  // 重置滚动到顶部
  if (parentRef.current) {
    parentRef.current.scrollTop = 0;
  }
  if (rowVirtualizer.scrollOffset !== 0) {
    rowVirtualizer.scrollOffset = 0;
  }

  try {
    const filters = {
      time_start: filterOptions.timeRange.start,
      time_end: filterOptions.timeRange.end,
      levels: filterOptions.levels,
      file_pattern: filterOptions.filePattern || null
    };

    await invoke("search_logs", {
      query: trimmedQuery,
      searchPath: activeWorkspace.path,
      filters,
    });

    // 更新执行次数
    if (currentQuery) {
      currentQuery.metadata.executionCount += 1;
      setCurrentQuery({...currentQuery});
    }
  } catch (err) {
    console.error('Search failed:', err);
    setIsSearching(false);
    addToast('error', `搜索失败: ${err}`);
  }
}, [query, activeWorkspace, filterOptions, currentQuery, addToast]);
```

### 步骤 3: 添加搜索事件监听和滚动管理

**文件**: `SearchPage.tsx`

```typescript
useEffect(() => {
  const abortController = new AbortController();
  const unlisteners: Array<() => void> = [];

  const setupListeners = async () => {
    try {
      const [resultsUnlisten, summaryUnlisten, completeUnlisten, errorUnlisten, startUnlisten] = 
        await Promise.all([
          listen<LogEntry[]>('search-results', (e) => {
            setLogs(prev => [...prev, ...e.payload]);
          }),
          listen<SearchResultSummary>('search-summary', (e) => {
            // ... 现有代码
          }),
          listen('search-complete', (e) => {
            setIsSearching(false);
            // 滚动到顶部显示结果
            setTimeout(() => {
              if (deferredLogs.length > 0) {
                rowVirtualizer.scrollToIndex(0);
              }
            }, 50);
            // ... 现有代码
          }),
          listen('search-error', (e) => {
            setIsSearching(false);
            addToast('error', `搜索失败: ${e.payload}`);
          }),
          listen('search-start', () => {
            // 清空并重置滚动
            setLogs([]);
            setSearchSummary(null);
            setKeywordStats([]);
            if (parentRef.current) {
              parentRef.current.scrollTop = 0;
            }
            rowVirtualizer.scrollOffset = 0;
          }),
        ]);
      
      unlisteners.push(...[resultsUnlisten, summaryUnlisten, completeUnlisten, errorUnlisten, startUnlisten]);
    } catch (error) {
      if (!abortController.signal.aborted) {
        console.error('Failed to setup event listeners:', error);
      }
    }
  };

  setupListeners();

  return () => {
    abortController.abort();
    unlisteners.forEach(unlisten => {
      try { unlisten(); } catch {}
    });
  };
}, [addToast, keywordColors, rowVirtualizer, deferredLogs.length]);
```

### 步骤 4: 添加边界条件处理

**文件**: `SearchPage.tsx`

在虚拟滚动配置中增强鲁棒性：
```typescript
const rowVirtualizer = useVirtualizer({ 
  count: deferredLogs.length, 
  getScrollElement: () => {
    if (!parentRef.current) return null;
    return parentRef.current;
  }, 
  estimateSize: useCallback(() => 32, []),
  overscan: 15,
  measureElement: (element) => {
    if (!element) return 32;
    try {
      const rect = element.getBoundingClientRect();
      return rect.height > 0 ? rect.height : 32;
    } catch {
      return 32;
    }
  },
});
```

## 依赖关系
- 步骤 1 是核心功能（关键词自动搜索）
- 步骤 2 支撑步骤 1
- 步骤 3 处理滚动和事件
- 步骤 4 提供边界保护

## 验证方法
1. 运行前端开发服务器
2. 输入关键词，观察是否自动触发搜索
3. 添加/删除关键词，验证结果是否刷新
4. 多次搜索确认滚动正确重置