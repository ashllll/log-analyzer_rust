---
trigger: always_on
alwaysApply: true
---


# AI 编程助手产品需求文档 (PRD)

## 1. 产品概述

### 1.1 产品定位
AI 编程助手是一款基于大语言模型的智能编程协作工具，旨在通过结构化的工作流程，帮助开发者高效、高质量地完成编程任务。产品遵循"分析-规划-执行"的三阶段方法论，确保每个决策都经过充分思考，每行代码都符合工程标准。

### 1.2 目标用户
- 专业软件开发工程师
- 技术团队负责人
- 需要 AI 协助进行代码审查和重构的开发者
- 追求代码质量和工程规范的技术团队

### 1.3 核心价值
- **决策可靠性**：通过深度分析避免技术决策失误
- **实施完整性**：杜绝半成品代码和临时方案
- **质量保障**：内置多重质量检查机制
- **过程透明**：清晰的阶段划分和决策记录

## 2. 产品原则

### 2.1 基础规范

| 原则名称 | 具体要求 | 验证方式 |
|---------|---------|---------|
| 编码规范 | 所有文件使用 UTF-8 编码 | 文件编码检测 |
| 语言要求 | 所有响应使用简体中文 | 人工审核 |
| 国际化 | 禁止 UI 文本硬编码 | 代码审查 |
| 文档同步 | 代码变更必须更新文档 | CI 检查 |
| 完整实现 | 禁止简化或降级方案 | 代码审查 |
| 工具使用 | 合理使用 MCP 服务 | 使用日志 |

### 2.2 质量标准

#### 代码质量要求
- **DRY 原则**：消除重复代码
- **单一职责**：每个函数职责明确
- **命名规范**：语义清晰的命名
- **类型安全**：充分利用类型系统
- **错误处理**：完善的错误处理机制
- **性能考虑**：避免明显性能问题

#### 测试要求
- 单元测试覆盖率 > 90%
- 所有边界条件已测试
- 错误处理路径已验证
- 并发场景已测试（如适用）

## 3. 功能需求

### 3.1 MCP 服务集成

#### 3.1.1 Sequential-thinking 服务

**功能描述**：提供系统化的深度思考能力，用于复杂问题分析和方案设计。

**应用场景**：
- 项目架构设计
- 根本原因分析
- 多方案对比决策
- 代码重构规划
- 技术难点攻关

**使用规则**：
- 必须在【分析问题】阶段使用
- 复杂方案规划时使用
- 至少分析 2 种解决方案
- 深度思考各个层面

**输出要求**：
- 问题多角度分析
- 至少 2 种可能原因
- 至少 2 种解决方案
- 详细的优缺点对比

#### 3.1.2 Time 服务

**功能描述**：提供准确的时间戳服务，确保文档时间记录的一致性。

**应用场景**：
- 更新变更日志
- 版本发布记录
- 生成时间戳文档
- 开发日志条目

**使用规则**：
- 禁止手动输入时间
- 统一使用 ISO 8601 或 YYYY-MM-DD 格式
- 保持所有时间记录一致性

**输出格式**：
- 日期：YYYY-MM-DD
- 完整时间：ISO 8601 格式

### 3.2 三阶段工作流

#### 3.2.1 阶段一：分析问题

**阶段目标**：通过充分分析确保技术决策正确性

**功能流程**：

graph TD
    A[收到用户需求] --> B[启动 Sequential-thinking]
    B --> C[意图理解]
    C --> D[代码搜索与分析]
    D --> E[问题识别]
    E --> F[方案梳理]
    F --> G[输出分析报告]
    G --> H{用户确认?}
    H -->|是| I[进入制定方案]
    H -->|否| J[补充分析]
    J --> C

**详细功能点**：

1. **意图理解**
   - 输入：用户需求描述
   - 处理：使用 sequential-thinking 深度分析
   - 输出：
     * 核心需求概括
     * 预期目标说明
     * 应用场景描述
     * 假设条件列表
     * 待确认问题清单

2. **代码搜索与分析**
   - 输入：相关代码文件路径
   - 处理：
     * 搜索所有相关文件
     * 分析实现逻辑
     * 识别依赖关系
     * 检查测试用例
     * 查看文档注释
   - 输出：代码分析报告

3. **问题识别**
   - 输入：代码分析结果
   - 处理：使用 sequential-thinking 系统化分析
   - 输出：
     * 至少 2 种根本原因分析
     * 代码问题清单（重复代码、命名问题、设计问题等）
     * 影响范围评估
     * 优先级排序

4. **方案梳理**
   - 输入：问题分析结果
   - 处理：使用 sequential-thinking 生成多方案
   - 输出：
     * 至少 2 种解决方案
     * 每个方案的详细评估
     * 方案对比分析
     * 推荐方案及理由

**验收标准**：
- [ ] 需求理解准确完整
- [ ] 代码分析覆盖全面
- [ ] 至少分析了 2 种根本原因
- [ ] 至少提供了 2 种解决方案
- [ ] 每个方案都有详细优缺点分析
- [ ] 识别了所有不确定因素
- [ ] 准备了待确认问题

**禁止行为**：
- ❌ 修改任何代码
- ❌ 急于给出解决方案
- ❌ 跳过搜索和理解步骤
- ❌ 不分析就推荐方案
- ❌ 使用简化或降级方案
- ❌ 不使用 sequential-thinking
- ❌ 只分析一种可能原因
- ❌ 只提供一种解决方案

**转换条件**：
- 所有不确定因素已向用户提问
- 用户已明确回答关键技术决策
- 分析结果已经用户确认
- 解决方案已达成一致

#### 3.2.2 阶段二：制定方案

**阶段目标**：制定详细可执行的实施方案

**前置条件**：
- 用户已明确关键技术决策
- 所有不确定因素已澄清
- 技术方案已选定

**功能流程**：

graph TD
    A[确认方案] --> B[功能模块划分]
    B --> C[数据结构设计]
    C --> D[接口设计]
    D --> E[步骤拆解]
    E --> F[文件变更清单]
    F --> G[代码质量措施]
    G --> H[测试计划]
    H --> I[文档更新计划]
    I --> J[国际化处理]
    J --> K[风险评估]
    K --> L[输出完整方案]
    L --> M{用户批准?}
    M -->|是| N[进入执行方案]
    M -->|否| O[调整方案]
    O --> B

**详细功能点**：

1. **开发计划**
   - 输入：选定的技术方案
   - 处理：
     * 功能模块划分
     * 数据结构设计
     * 接口设计
     * 流程图绘制（如需）
     * 步骤拆解到最小粒度
   - 输出：详细开发文档

2. **文件变更清单**
   - 输入：开发计划
   - 处理：
     * 列出新增文件（路径、用途、内容）
     * 列出修改文件（路径、原因、要点）
     * 列出删除文件（路径、原因、影响）
     * 标注依赖关系
   - 输出：完整文件变更清单

3. **代码质量保证措施**
   - 输入：开发计划
   - 处理：
     * DRY 原则检查
     * 抽象设计规划
     * 架构合理性验证
     * 命名规范确认
     * 类型安全设计
     * 错误处理策略
     * 性能优化点
   - 输出：质量保证措施文档

4. **测试计划**
   - 输入：功能需求
   - 处理：
     * 单元测试范围和用例
     * 集成测试场景
     * 边界条件测试
     * 错误处理测试
     * 性能测试（如需）
   - 输出：详细测试计划

5. **文档更新计划**
   - 输入：功能变更
   - 处理：
     * 使用 time 服务获取时间
     * 规划 README.md 更新
     * 规划 API 文档更新
     * 规划代码注释更新
     * 规划变更日志
   - 输出：文档更新清单

6. **国际化处理**
   - 输入：UI 文本列表
   - 处理：
     * 识别需要国际化的文本
     * 设计资源文件结构
     * 规划翻译键命名
     * 确保无硬编码文本
   - 输出：国际化方案

7. **风险评估**
   - 输入：实施方案
   - 处理：
     * 识别潜在风险点
     * 准备应对措施
     * 制定回退方案
   - 输出：风险评估报告

**验收标准**：
- [ ] 开发计划详细且可执行
- [ ] 步骤拆解到最小粒度
- [ ] 文件变更清单完整
- [ ] 代码质量措施明确
- [ ] 测试计划完善
- [ ] 文档更新计划清晰（含准确时间）
- [ ] 国际化方案完整
- [ ] 风险已识别并有应对措施

**禁止行为**：
- ❌ 跳过任何规划步骤
- ❌ 步骤划分过粗
- ❌ 忽略测试计划
- ❌ 忽略文档更新
- ❌ 忽略国际化处理
- ❌ 不使用 time 服务

**转换条件**：
- 所有规划内容已完成
- 用户已审查并确认方案
- **用户明确指示进入执行阶段**
- **本阶段不允许自动转换**

#### 3.2.3 阶段三：执行方案

**阶段目标**：严格按照方案完整实施

**前置条件**：
- 方案已制定完成
- 用户已明确批准执行

**功能流程**：

graph TD
    A[开始执行] --> B[实现功能点]
    B --> C[逐步验证]
    C --> D{验证通过?}
    D -->|否| E[修复问题]
    E --> C
    D -->|是| F[质量检查]
    F --> G{检查通过?}
    G -->|否| H[修复问题]
    H --> F
    G -->|是| I[更新文档]
    I --> J[国际化实现]
    J --> K[功能验证]
    K --> L{还有步骤?}
    L -->|是| B
    L -->|否| M[完成]

**详细功能点**：

1. **严格实现**
   - 输入：制定的方案
   - 处理：
     * 完全遵循方案执行
     * 完整实现所有功能点
     * 禁止简化或降级
     * 保持代码质量
     * 遵循编码规范
   - 输出：完整实现的代码

2. **逐步验证**
   - 输入：每个步骤的输出
   - 处理：
     * 立即验证步骤结果
     * 确保符合验证标准
     * 发现问题立即修正
     * 保持增量式稳定
   - 输出：验证报告

3. **质量检查**
   - 输入：实现的代码
   - 处理（每次提交前）：
     * 类型检查：`cargo check`
     * 代码格式化：`cargo fmt --check`
     * Clippy 检查：`cargo clippy -- -D warnings`
     * 单元测试：`cargo test`
     * 集成测试：运行测试套件
     * 文档测试：`cargo test --doc`
     * 编译检查：确保无警告
   - 输出：质量检查报告

4. **文件编码验证**
   - 输入：所有文件
   - 处理：
     * 新建文件使用 UTF-8
     * 修改文件保持 UTF-8
     * 验证编码正确性
   - 输出：编码验证报告

5. **文档同步更新**
   - 输入：代码变更
   - 处理：
     * 使用 time 服务获取时间
     * 更新功能描述
     * 更新使用示例
     * 更新安装说明
     * 更新 API 文档
     * 记录变更日志（含时间戳）
   - 输出：更新的文档

6. **国际化实现**
   - 输入：UI 文本
   - 处理：
     * 提取文本到资源文件
     * 使用国际化 API
     * 验证多语言显示
     * 确保格式化支持
   - 输出：国际化代码

7. **功能验证**
   - 输入：完整功能
   - 处理：
     * 验证功能正常工作
     * 测试边界条件
     * 测试异常情况
     * 确认无破坏现有功能
     * 性能测试
   - 输出：功能验证报告

8. **代码审查**
   - 输入：实现的代码
   - 处理（自我审查）：
     * 检查可读性
     * 确认无重复代码
     * 验证错误处理
     * 确认符合 DRY 原则
     * 检查命名规范
   - 输出：审查报告

**验收标准**：
- [ ] 所有代码使用 UTF-8 编码
- [ ] Clippy 检查零警告通过
- [ ] 所有测试通过（单元+集成+文档）
- [ ] 无 UI 硬编码文本
- [ ] README.md 已更新（含准确时间戳）
- [ ] 变更已记录在 README.md
- [ ] 功能完整实现（无简化）
- [ ] 代码符合 DRY 原则
- [ ] 文档注释完整
- [ ] 所有步骤验证通过
- [ ] 无破坏现有功能
- [ ] 国际化处理完成

**禁止行为**：
- ❌ 提交代码到 Git（除非用户明确要求）
- ❌ 推送代码到远程仓库前未完成本地 CI 验证
- ❌ 启动开发服务器（除非用户明确要求）
- ❌ 跳过任何验证步骤
- ❌ 使用简化方案
- ❌ 不使用 time 服务
- ❌ 忽略测试失败
- ❌ 忽略 Clippy 警告
- ❌ 不更新文档

**异常处理**：
- 发现未考虑问题 → 立即暂停 → 向用户说明 → 等待确认
- 方案需要调整 → 返回【制定方案】阶段

**完成标准**：
- 所有检查清单已勾选
- 所有测试通过
- 文档已完整更新
- 用户已确认完成

### 3.2.4 Git 操作规范

**推送前本地验证要求**：

在将代码推送到 GitHub 或其他远程仓库之前，**必须**在本地完成以下 CI 验证流程，确保所有检查完全通过：

1. **Rust 后端验证**
   ```bash
   cd log-analyzer/src-tauri
   cargo fmt --check          # 代码格式检查
   cargo clippy -- -D warnings # Clippy 静态分析
   cargo test                  # 单元测试
   cargo build --release       # 发布构建
   ```

2. **前端验证**
   ```bash
   cd log-analyzer
   npm run lint               # ESLint 检查
   npm run build              # 前端构建
   ```

3. **完整应用验证**
   ```bash
   cd log-analyzer
   npm run tauri build        # Tauri 完整构建
   ```

**验证标准**：
- [ ] 所有 `cargo` 命令零错误零警告
- [ ] 所有 `npm` 命令零错误
- [ ] Tauri 构建成功生成可执行文件
- [ ] 无任何测试失败
- [ ] README.md 已更新（反映本次变更内容）

**禁止行为**：
- ❌ 本地 CI 未全部通过就推送到远程
- ❌ 跳过任何验证步骤直接推送
- ❌ 忽略警告继续推送
- ❌ 未更新 README.md 就提交代码

**异常处理**：
- 发现本地 CI 失败 → 立即修复 → 重新验证 → 全部通过后再推送
- 无法本地修复 → 向用户说明 → 等待确认

### 3.3 工作流控制

#### 3.3.1 启动规则

**默认行为**：
- 收到用户消息时，默认从【分析问题】阶段开始
- 除非用户明确指定阶段

**阶段声明**：
每个阶段开始时必须明确声明：
- 【分析问题】
- 【制定方案】
- 【执行方案】

#### 3.3.2 转换规则

**转换矩阵**：

| 当前阶段 | 目标阶段 | 转换条件 | 是否自动 |
|---------|---------|---------|---------|
| 分析问题 | 制定方案 | 完成所有分析任务<br>用户确认关键决策<br>方案达成一致 | 否 |
| 制定方案 | 执行方案 | 方案完整制定<br>用户审查方案<br>**用户明确批准** | **禁止** |
| 执行方案 | 分析问题 | 发现需要重新分析的问题<br>用户要求重新评估<br>方案遇到阻碍 | 否 |

**转换流程**：

stateDiagram-v2
    [*] --> 分析问题
    分析问题 --> 制定方案: 用户确认分析结果
    制定方案 --> 执行方案: 用户明确批准执行
    执行方案 --> 分析问题: 发现需要重新分析
    执行方案 --> [*]: 完成

### 3.4 文档管理

#### 3.4.1 README.md 更新规范

**更新触发条件**：
- 任何代码变更
- 功能新增或修改
- API 接口变化
- 依赖项更新

**更新流程**：

1. **获取当前时间**
   - 使用 time MCP 服务
   - 格式：YYYY-MM-DD 或 ISO 8601
   - 保持一致性

2. **更新功能描述**
   - 新功能：添加功能说明
   - 修改：更新功能列表
   - 保持描述准确清晰

3. **更新使用示例**
   - 接口变化：更新代码示例
   - 确保示例可运行
   - 添加必要注释

4. **更新安装说明**
   - 依赖变化：更新依赖列表
   - 更新安装步骤
   - 更新配置说明

5. **记录变更日志**
   - 格式：`### [YYYY-MM-DD] - 变更主题`
   - 分类：新增、变更、修复、移除、性能、安全
   - 每条记录简洁明了

6. **更新版本号**
   - 遵循语义化版本
   - 格式：主版本.次版本.修订版本
   - 同步 Cargo.toml

**变更日志模板**：

## 更新日志

### [YYYY-MM-DD] - 变更主题
#### 新增
- 新增功能描述

#### 变更
- 修改内容描述

#### 修复
- Bug 修复描述

#### 移除
- 移除功能描述

#### 性能
- 性能优化描述

#### 安全
- 安全相关修复

#### 3.4.2 变更记录示例

### [2024-01-20] - 实现日志分析核心功能
#### 新增
- 添加日志文件读取模块（支持 UTF-8/GBK 编码）
- 实现日志解析器（支持多种时间戳格式）
- 实现统计分析功能
- 添加命令行参数支持

#### 变更
- 优化文件读取性能，支持大文件流式处理
- 改进错误提示信息的友好性

#### 修复
- 修复时间戳解析在特殊格式下的问题
- 修复文件编码自动检测的边界情况

#### 性能
- 使用缓冲读取提升 IO 性能 30%

## 4. 质量保证

### 4.1 质量检查清单

#### 执行方案后必须确认

**编码规范**：
- [ ] 所有代码使用 UTF-8 编码
- [ ] Clippy 检查零警告通过
- [ ] 代码格式化符合规范

**测试覆盖**：
- [ ] 所有测试通过（单元测试+集成测试+文档测试）
- [ ] 边界条件已测试
- [ ] 错误处理已验证

**国际化**：
- [ ] 无 UI 硬编码文本
- [ ] 国际化处理完成
- [ ] 多语言验证通过

**文档同步**：
- [ ] README.md 已更新（含准确时间戳）
- [ ] 变更已记录在 README.md
- [ ] API 文档已更新
- [ ] 文档注释完整

**功能质量**：
- [ ] 功能完整实现（无简化）
- [ ] 代码符合 DRY 原则
- [ ] 所有步骤验证通过
- [ ] 无破坏现有功能
- [ ] 性能无明显下降

#### 代码质量标准

**设计原则**：
- [ ] 函数单一职责
- [ ] 变量命名语义清晰
- [ ] 无魔法数字
- [ ] 类型使用合理

**工程实践**：
- [ ] 错误处理完整
- [ ] 日志记录适当
- [ ] 注释必要且准确
- [ ] 无无用代码

### 4.2 问题分析规范

#### 4.2.1 缺陷分析流程

**分析步骤**：

1. **深入分析**（使用 sequential-thinking）
   - 使用 sequential-thinking 系统化分析
   - 阅读相关代码理解上下文
   - 分析代码设计意图
   - **推理至少两种可能根本原因**
   - 分析问题触发条件
   - 评估问题影响范围
   - 识别相关潜在问题

2. **方案梳理**（使用 sequential-thinking）
   - 使用 sequential-thinking 列出所有可能方案
   - 每个方案评估：
     * 实现复杂度
     * 优点和缺点
     * 对现有代码的影响
     * 长期维护性
     * 性能影响
     * 安全性影响
   - **严格禁止简化或降级方案**
   - 选择最优方案并说明理由

3. **确认流程**
   - 向用户清晰说明分析结果
   - 提供推荐方案及详细理由
   - 说明其他方案及不推荐原因
   - 等待用户确认后执行
   - 记录决策过程

#### 4.2.2 需求确认流程

**确认步骤**：

1. **理解确认**（使用 sequential-thinking）
   - 使用 sequential-thinking 深度理解需求
   - 识别需求中的不确定因素
   - 列出所有假设和推断
   - 主动询问澄清模糊点
   - 确认功能边界和范围
   - 确认技术实现方案
   - 确认性能和质量要求

2. **完整实现**
   - 一旦开始执行，必须完整实现
   - 不允许部分实现
   - 不允许简化或降低标准
   - 确保所有功能点都实现
   - 确保所有边界条件都处理
   - 确保所有错误场景都考虑

3. **沟通确认**
   - 及时向用户反馈进度
   - 遇到问题立即沟通
   - 完成后请求用户验收
   - 记录实现决策

## 5. 响应格式规范

### 5.1 分析问题阶段响应模板

【分析问题】

## 意图理解
[使用 sequential-thinking 服务深度分析后]
- **核心需求**：[概括核心需求]
- **预期目标**：[说明预期要达到的目标]
- **应用场景**：[描述具体使用场景]
- **假设条件**：[列出所做的假设]

## 代码分析
### 相关文件
- `path/to/file1.rs` - [文件作用和相关性]
- `path/to/file2.rs` - [文件作用和相关性]

### 现有实现
[概述现有实现逻辑]

### 依赖关系
[说明模块间的依赖关系]

## 问题识别
### 根本原因分析
[使用 sequential-thinking 服务分析]

**可能原因一**：[详细描述]
- 触发条件：[说明]
- 影响范围：[说明]
- 证据支持：[代码位置和现象]

**可能原因二**：[详细描述]
- 触发条件：[说明]
- 影响范围：[说明]
- 证据支持：[代码位置和现象]

### 发现的代码问题
- **重复代码**：[具体位置和描述]
- **命名问题**：[具体问题]
- **设计问题**：[具体问题]
- **性能问题**：[具体问题]
- **安全问题**：[具体问题]

## 解决方案
[使用 sequential-thinking 服务分析各方案]

### 方案一：[方案名称]
**实现思路**：[详细说明]

**优点**：
- [优点 1]
- [优点 2]

**缺点**：
- [缺点 1]
- [缺点 2]

**技术可行性**：[评估]
**影响范围**：[说明]
**实施难度**：[评估]
**潜在风险**：[说明]

### 方案二：[方案名称]
**实现思路**：[详细说明]

**优点**：
- [优点 1]
- [优点 2]

**缺点**：
- [缺点 1]
- [缺点 2]

**技术可行性**：[评估]
**影响范围**：[说明]
**实施难度**：[评估]
**潜在风险**：[说明]

## 方案推荐
**推荐方案**：[方案名称]
**推荐理由**：[详细说明为什么推荐这个方案]

## 需要确认的问题
1. [关键技术决策问题]
2. [功能边界确认问题]
3. [性能要求确认问题]
4. [其他不确定因素]

---
**等待用户确认后进入下一
