# 多关键词搜索结果不完整问题修复方案

## 问题分析

### 问题表现
1. **两个或两个以上关键词搜索后结果不全部显示**
2. **第二次搜索后只显示部分搜索结果**

### 根本原因
在 [query_executor.rs](file:///f:/github/log-analyzer_rust/log-analyzer/src-tauri/src/services/query_executor.rs) 的 `match_with_details` 方法中（第 163-197 行）存在以下问题：

1. **只获取第一个匹配**：使用 `engine_find` 方法只返回 `Option<MatchResult>`，只获取每个引擎的第一个匹配结果
2. **Aho-Corasick 引擎能力浪费**：Aho-Corasick 算法天然支持多模式匹配，但当前实现只取第一个匹配
3. **matched_keywords 统计不完整**：导致关键词统计信息只反映部分匹配

## 修复方案

### 步骤 1: 为 RegexEngine 添加 find_iter 方法
**文件**: `regex_engine.rs`

为所有引擎变体添加 `find_iter` 方法，返回所有匹配的迭代器：
```rust
pub fn find_iter<'a>(&'a self, text: &'a str) -> Box<dyn Iterator<Item = MatchResult> + 'a>
```

### 步骤 2: 修改 match_with_details 收集所有匹配
**文件**: `query_executor.rs`

修改 `match_with_details` 方法：
```rust
pub fn match_with_details(&self, plan: &ExecutionPlan, line: &str) -> Option<Vec<MatchDetail>> {
    if !self.matches_line(plan, line) {
        return None;
    }

    let mut details = Vec::new();

    for compiled in &plan.engines {
        // 使用 find_iter 收集所有匹配
        for mat in Self::engine_find_all(&compiled.engine, line) {
            let term_value = /* ... */;
            details.push(MatchDetail { /* ... */ });
        }
    }

    if details.is_empty() {
        None
    } else {
        Some(details)
    }
}
```

### 步骤 3: 添加 engine_find_all 辅助方法
**文件**: `query_executor.rs`

```rust
fn engine_find_all(engine: &RegexEngine, text: &str) -> Vec<crate::services::regex_engine::MatchResult> {
    match engine {
        RegexEngine::AhoCorasick(e) => e.find_iter(text).collect(),
        RegexEngine::Automata(e) => e.find_iter(text).collect(),
        RegexEngine::Standard(e) => {
            e.find_iter(text).collect()
        }
    }
}
```

### 步骤 4: 添加单元测试
**文件**: `query_executor.rs`

```rust
#[test]
fn test_match_with_details_all_keywords() {
    let mut executor = QueryExecutor::new(10);
    let query = build_query(
        vec![
            build_term("t1", "error", QueryOperator::And, false),
            build_term("t2", "timeout", QueryOperator::And, false),
            build_term("t3", "warning", QueryOperator::And, false),
        ],
        QueryOperator::And,
    );
    let plan = executor.execute(&query).unwrap();

    let line = "error: timeout occurred, warning: system overloaded";
    let details = executor.match_with_details(&plan, line);
    
    assert!(details.is_some());
    let details = details.unwrap();
    assert_eq!(details.len(), 3, "Should match all 3 keywords");
}
```

## 依赖关系
- 步骤 1 是步骤 2 的前提
- 步骤 4 可独立进行

## 复杂度分析
- **时间复杂度**: O(n + m)，其中 n 是引擎数量，m 是总匹配数
- **空间复杂度**: O(m) 用于存储所有匹配详情

## 验证方法
1. 运行现有测试确保无回归
2. 添加新测试验证多关键词匹配
3. 手动测试多关键词搜索场景